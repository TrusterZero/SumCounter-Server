import * as ts from "typescript";
import { JsDocRenderer } from "./JsDocRenderer";
import { SourceFileDescriptor, Type } from "./psi";
export interface TsToJsdocOptions {
    readonly out: string;
    readonly externalIfNotMain?: string | null;
    readonly access?: string | null;
    /**
     * The path to examples dir.
     */
    readonly examples?: string | null;
}
export declare type ModulePathMapper = (oldPath: string) => string;
export declare function generate(basePath: string, config: ts.ParsedCommandLine, moduleName: string, main: string | null, options: TsToJsdocOptions): JsDocGenerator;
export declare class JsDocGenerator {
    readonly program: ts.Program;
    readonly relativeOutDir: string;
    readonly moduleName: string | null;
    private readonly mainFile;
    private readonly commonSourceDirectory;
    private readonly options;
    private readonly baseUrl;
    readonly moduleNameToResult: Map<string, SourceFileDescriptor>;
    private currentSourceModuleId;
    readonly renderer: JsDocRenderer;
    readonly mainMappings: Map<string, string[]>;
    constructor(program: ts.Program, relativeOutDir: string, moduleName: string | null, mainFile: string | null, commonSourceDirectory: string, options: TsToJsdocOptions, baseUrl?: string | undefined);
    private sourceFileToModuleId(sourceFile);
    generate(sourceFile: ts.SourceFile): void;
    private handleExportFromMain(node);
    getTypeNamePathByNode(node: ts.Node): Array<string | Type> | null;
    private typesToList(types, node);
    getTypeNames(type: ts.Type, node: ts.Node): Array<string | Type> | null;
    getTypeNamePath(type: ts.Type): string | null;
    private describeEnum(node);
    private describeVariable(node);
    private describeFunction(node);
    private static isHidden(jsDoc);
    private processClassOrInterface(node);
    private describeProperty(node, isParentClass);
    private renderMethod(node);
    private computeTypePath();
}
export interface Example {
    name: string;
    content: string;
    lang: string;
}
